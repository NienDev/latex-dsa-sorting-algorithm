\documentclass[a4paper]{article}

\usepackage[margin=1.5in]{geometry}    % For margin alignment
\usepackage[utf8]{inputenc}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{amsmath}
\usepackage[dvipsnames]{xcolor}
\algdef{SE}[DOWHILE]{Do}{doWhile}{\algorithmicdo}[1]{\algorithmicwhile\ #1}%
\title{Algorithm template}
\author{Roy}

\date{\today}    % Today's date

\begin{document}
\maketitle
\section{Demo code}

\begin{algorithm}
\caption{Selection Sort}
\begin{algorithmic}

\Procedure{Selection Sort}{$a,n$} 
    \For {$i = 0 \textbf{ to } n-1$}
		\State $min \gets i$
		\For {$j = i+1 \textbf{ to } n$}
			\If{$a[j]<a[min]$}
				min = j
			\EndIf
		\EndFor
		
		\If{$min \neq i$}
			\State Swap(a[min], a[i])
		\EndIf
	\EndFor
\EndProcedure
%https://www.tutorialspoint.com/data_structures_algorithms/selection_sort_algorithm.htm

\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\begin{algorithmic}
		\Procedure{Bubble Sort}{$a, n$}
			\For {$i = 0 \textbf{ to }n-i-1$}
				\For {$j = 0 \textbf{ to }n-i-2$}
					\If{$a[j]>a[j+1]$}
						\State Swap(a[j], a[j+1])
					\EndIf
				\EndFor
			\EndFor
		\EndProcedure
	\end{algorithmic}
\end{algorithm}
%https://www.mygreatlearning.com/blog/bubble-sort/#sh11

\begin{algorithm}
	\begin{algorithmic}
		\Procedure{Radix Sort}{$a, d$}
		\State \textcolor{Gray}{//It works same as counting sort for d number of passes}
		\State \textcolor{Gray}{//Each key in a[0..n-1] is a d-digit integer}
		\State \textcolor{Gray}{//Digits are numbered 1 to d from right to left}
		\For {$j=1\textbf{ to }d$}
			\State \textcolor{Gray}{//a[]-- Initial Array to sort}
			\State int count[10] = \{0\}
			\State \textcolor{Gray}{//Store the count of "keys" in count[]}
			\State \textcolor{Gray}{//key- it is number at digit place j}
			\For {$i=0\textbf{ to }n$}
				\State count[key of (a[i]) in pass j]++
			\EndFor
			\For{$i=1\textbf{ to }10$}
				\State count[k] = count[k] + count[k-1]
			\EndFor
			
			\State \textcolor{Gray}{//Build the resulting array by checking}
			\State \textcolor{Gray}{//new position of a[i] from count[k]}
			\For {$i=n-1\textbf{ downto }0$}
				\State result[count[key of (a[i])] = a[j]
				\State count[key of (a[i])]$--$
			\EndFor
			
			\State \textcolor{Gray}{//Now main array a[] contains sorted numbers}
			\State \textcolor{Gray}{//according to current digit place}
			\For{$i=0\textbf{ to }n$}
				\State a[i] = result[i]
			\EndFor
		\EndFor
		\EndProcedure
	\end{algorithmic}
\end{algorithm}
%https://www.codingeek.com/algorithms/radix-sort-explanation-pseudocode-and-implementation/?fbclid=IwAR3V50-QQ7TA6GD12IaD3rufYsRg8dPANlSZTGfrHvZZvQ6Td2ILvW7pST4#5_pseudocode_of_radix_sort

\begin{algorithm}
	\begin{algorithmic}
		\Procedure{Heapify}{a, n, i}
			\State $max \gets i$
			\State $leftchild \gets 2i+1$
			\State $rightchild \gets 2i+2$
			\If{$leftchild \leq n \textbf{ and } a[i] < a[leftchild]$}
				\State $max \gets leftchild$
			\Else
				\State $max \gets i$
			\EndIf
			\If{$rightchild \leq n \textbf{ and } a[max] > a[rightchild]$}
				\State $max \gets rightchild$
			\EndIf
			\If{$max \neq i$}
				\State Swap(a[i], a[max])
				\State Heapify(a, n, max)
			\EndIf
		\EndProcedure
		\vspace{12pt}
		\Procedure{Heap Sort}{$a \text{: array, } n \text{: number of elements}$}
			\For {$i=n/2 \textbf{ downto }1$}
				Heapify(a, n, i)
			\EndFor
			
			\For{$i=n \textbf{ downto } 2$}
				\State Exchange a[1] with a[i]
				\State $n \gets n - 1$
				\State Heapify(a, i, 0)
			\EndFor
		\EndProcedure
	\end{algorithmic}
\end{algorithm}
%https://fullyunderstood.com/pseudocodes/heap-sort/

\begin{algorithm}
	\begin{algorithmic}
		\Procedure{Shaker Sort}{$a, n$}
			\Do
				\State $swapped \gets false$
				\For{$i=0\textbf{ to }n-2$}
					\State \textcolor{gray}{// test whether the two elements are in the wrong order}
					\If{$a[i]>a[i+1]$}
						\State \textcolor{gray}{// // let the two elements change places}
						\State swap(a[i], a[i+1])
						\State $swapped \gets true$
					\EndIf
				\EndFor
				\If	{not swapped}
					\State \textcolor{Gray}{// we can exit the outer loop here if no swaps occurred.}
					\State break do-while loop
				\EndIf
				\State $swapped \gets false$
				\For{$i=n-2\textbf{ to }0$}
					 \If{$a[i]>a[i+1]$}
						\State swap(a[i], a[i+1])
						\State $swapped \gets true$
					\EndIf
				\EndFor
			\doWhile{swapped} \Comment{\textcolor{Gray}{// if no elements have been swapped, then the list is sorted}}
		\EndProcedure
	\end{algorithmic}
\end{algorithm}
%https://iq.opengenus.org/cocktail-shaker-sort/

\begin{algorithm}
	\begin{algorithmic}
		\Procedure{Shell Sort}{$a, n$}
			\State \textcolor{Gray}{/* calculate interval*/}
			\While{$interval < n/3$}
				\State $interval = interval*3+1$ 
			\EndWhile
			\While{$interval > 0$}
				\For {$outer=interval\textbf{ to }n$}
					\State \textcolor{Gray}{/* select value to be inserted */}
					\State $valueToInsert = a[outer]$
					\State $inner = outer$
					\State \textcolor{Gray}{/*shift element towards right*/}
					\vspace{12pt}
					\While{$inner > interval - 1 \textbf{ and } a[inner - interval] \geq valueToInsert$}
						\State $a[inner] = a[inner-interval]$
						\State $inner = inner - interval$
					\EndWhile
					\vspace{12pt}
					\State \textcolor{Gray}{/* insert the number at hole position */}
					\State $a[inner] = valueToInsert$
				\EndFor
				\State \textcolor{Gray}{/* calculate interval*/}
				\State $interval = (interval-1)/3$
			\EndWhile
		\EndProcedure
	\end{algorithmic}
\end{algorithm}
%https://www.tutorialspoint.com/data_structures_algorithms/shell_sort_algorithm.htm

\begin{algorithm}
	\begin{algorithmic}
		\Procedure{Merge Sort}{$a, n$}
			\If{$n == 1$} 
				\State return a
			\EndIf
			\State l1 as array = a[0]...a[$n/2$]
			\State l2 as array = a[$n/2+1$]...a[n]
			\State l1 = mergeSort(l1)
			\State l2 = mergeSort(l2)
			\State return merge(l1, l2)
		\EndProcedure
		\vspace{12pt}
		\Procedure{merge}{a: array, b: array}
			\State c as array
			\While {a and b have elements}
				\If{$a[0]>b[0]$}
					\State add b[0] to the end of c
					\State remove b[0] from b
				\Else 
					\State add a[0] to the end of c
					\State remove a[0] from a
				\EndIf
			\EndWhile
			\While {a has elements}
				\State add a[0] to the end of c
				\State remove a[0] from a
			\EndWhile
			\While {b has elements}
				\State add b[0] to the end of c
				\State remove b[0] from a
			\EndWhile
			
			\State return c
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

\begin{algorithm}
	\begin{algorithmic}
		\Procedure{Quick Sort}{a, begin, end}
			\State pivotIndex = partition(a, begin, end)
			\State quickSort(a, begin, pivotIndex)
			\State quickSort(a, pivotIndex + 1, end)
		\EndProcedure
		
		\Procedure{Partition}{a, begin, end}
			\State set end as pivotIndex
			\State pIndex = beg - 1
			\For{$i=beg\textbf{ to }end-1$}
				\If{$a[i] < pivot$}
					\State Swap a[i] and a[pIndex]
					\State pIndex++
				\EndIf
			\EndFor
			\State Swap pivot and a[pIndex + 1]
			\State return pIndex + 1
		\EndProcedure
	\end{algorithmic}
\end{algorithm}
%https://www.tutorialspoint.com/data_structures_algorithms/merge_sort_algorithm.htm
\end{document}

%https://shantoroy.com/latex/how-to-write-algorithm-in-latex/